<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module zsets</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module zsets</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Sorted Sets.
<p>Copyright © (C) 2011 InakaLabs SRL</p>

<p><b>Authors:</b> Fernando Benavides (<a href="mailto:fernando.benavides@inakanetworks.com"><tt>fernando.benavides@inakanetworks.com</tt></a>), Chad DePue (<a href="mailto:chad@inakanetworks.com"><tt>chad@inakanetworks.com</tt></a>).</p>

<h2><a name="description">Description</a></h2>Sorted Sets
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-aggregate">aggregate()</a></h3>
<p><tt>aggregate() = sum | max | min</tt></p>


<h3 class="typedecl"><a name="type-direction">direction()</a></h3>
<p><tt>direction() = forward | backwards</tt></p>


<h3 class="typedecl"><a name="type-iterator">iterator()</a></h3>
<p><b>abstract datatype</b>: <tt>iterator(_Scores, _Members)</tt></p>


<h3 class="typedecl"><a name="type-limit">limit()</a></h3>
<p><tt>limit(Scores) = neg_infinity | infinity | {exc, Scores} | {inc, Scores}</tt></p>


<h3 class="typedecl"><a name="type-zset">zset()</a></h3>
<p><b>abstract datatype</b>: <tt>zset(_Scores, _Members)</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#count-3">count/3</a></td><td>Equivalent to <a href="#count-4"><tt>count(Min, Max, ZSet, forward)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#count-4">count/4</a></td><td>Returns the number of elements between Min and Max in ZSet.</td></tr>
<tr><td valign="top"><a href="#delete_any-2">delete_any/2</a></td><td>Removes the node with key Key from Tree1 if the key is present in the tree, otherwise does
       nothing; returns new tree.</td></tr>
<tr><td valign="top"><a href="#direction-1">direction/1</a></td><td>Returns the direction of the iterator.</td></tr>
<tr><td valign="top"><a href="#enter-2">enter/2</a></td><td>Equivalent to <a href="#enter-3"><tt>enter(Score, Member, ZSet)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#enter-3">enter/3</a></td><td>Adds a new element to the zset.</td></tr>
<tr><td valign="top"><a href="#find-2">find/2</a></td><td>This function searches for a key in a zset.</td></tr>
<tr><td valign="top"><a href="#intersection-2">intersection/2</a></td><td>Returns the intersection of the non-empty list of ZSets generating the resulting scores using Aggregate in order.</td></tr>
<tr><td valign="top"><a href="#intersection-3">intersection/3</a></td><td>Returns the intersection of ZSet1 and ZSet2 generating the resulting scores using Aggregate.</td></tr>
<tr><td valign="top"><a href="#iterator-1">iterator/1</a></td><td>Equivalent to <a href="#iterator-2"><tt>iterator(ZSet, forward)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#iterator-2">iterator/2</a></td><td>Returns an iterator that can be used for traversing the entries of Tree; see <a href="#next-1"><code>next/1</code></a>.</td></tr>
<tr><td valign="top"><a href="#list-3">list/3</a></td><td>Equivalent to <a href="#list-4"><tt>list(Min, Max, ZSet, forward)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#list-4">list/4</a></td><td>Returns the list of elements with scores between the specified limits.</td></tr>
<tr><td valign="top"><a href="#map-2">map/2</a></td><td>Executes Fun in each element and returns the zset with the scores returned by it.</td></tr>
<tr><td valign="top"><a href="#new-0">new/0</a></td><td>Creates an empty <a href="#zset-2"><code>zset/2</code></a></td></tr>
<tr><td valign="top"><a href="#next-1">next/1</a></td><td>Returns {Score, Member, Iter2} where Score is the smallest score referred to by the iterator
  Iter1, and Iter2 is the new iterator to be used for traversing the remaining nodes, or the atom
  none if no nodes remain.</td></tr>
<tr><td valign="top"><a href="#range-3">range/3</a></td><td>Equivalent to <a href="#range-4"><tt>range(Start, Stop, ZSet, forward)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#range-4">range/4</a></td><td>Returns the list of elements between the Start'th one and the Stop'th one inclusive.</td></tr>
<tr><td valign="top"><a href="#size-1">size/1</a></td><td>Returns the size of the zset.</td></tr>
<tr><td valign="top"><a href="#to_list-1">to_list/1</a></td><td>Converts the sorted set into a list of {Score, Member} pairs.</td></tr>
<tr><td valign="top"><a href="#union-2">union/2</a></td><td>Returns the union of the non-empty list of ZSets generating the resulting scores using Aggregate in order.</td></tr>
<tr><td valign="top"><a href="#union-3">union/3</a></td><td>Returns the union of ZSet1 and ZSet2 generating the resulting scores using Aggregate.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="count-3">count/3</a></h3>
<div class="spec">
<p><tt>count(Min::<a href="#type-limit">limit</a>(Scores), Max::<a href="#type-limit">limit</a>(Scores), ZSet::<a href="#type-zset">zset</a>(Scores, _Members)) -&gt; non_neg_integer()</tt><br></p>
</div><p>Equivalent to <a href="#count-4"><tt>count(Min, Max, ZSet, forward)</tt></a>.</p>


<h3 class="function"><a name="count-4">count/4</a></h3>
<div class="spec">
<p><tt>count(Min::<a href="#type-limit">limit</a>(Scores), Max::<a href="#type-limit">limit</a>(Scores), ZSet::<a href="#type-zset">zset</a>(Scores, _Members), Direction::<a href="#type-direction">direction()</a>) -&gt; non_neg_integer()</tt><br></p>
</div><p>Returns the number of elements between Min and Max in ZSet</p>

<h3 class="function"><a name="delete_any-2">delete_any/2</a></h3>
<div class="spec">
<p><tt>delete_any(Members, ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; <a href="#type-zset">zset</a>(Scores, Members)</tt><br></p>
</div><p>Removes the node with key Key from Tree1 if the key is present in the tree, otherwise does
       nothing; returns new tree.</p>

<h3 class="function"><a name="direction-1">direction/1</a></h3>
<div class="spec">
<p><tt>direction(Iter::<a href="#type-iterator">iterator</a>(_Scores, _Members)) -&gt; <a href="#type-direction">direction()</a></tt><br></p>
</div><p>Returns the direction of the iterator</p>

<h3 class="function"><a name="enter-2">enter/2</a></h3>
<div class="spec">
<p><tt>enter(X1::{Score, Member}, ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; <a href="#type-zset">zset</a>(Scores, Members)</tt>
<ul class="definitions"><li><tt>Score = Scores</tt></li><li><tt>Member = Members</tt></li></ul></p>
</div><p>Equivalent to <a href="#enter-3"><tt>enter(Score, Member, ZSet)</tt></a>.</p>


<h3 class="function"><a name="enter-3">enter/3</a></h3>
<div class="spec">
<p><tt>enter(Score, Member, ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; <a href="#type-zset">zset</a>(Scores, Members)</tt>
<ul class="definitions"><li><tt>Score = Scores</tt></li><li><tt>Member = Members</tt></li></ul></p>
</div><p>Adds a new element to the zset.
       If the element is already present it justs updates its score</p>

<h3 class="function"><a name="find-2">find/2</a></h3>
<div class="spec">
<p><tt>find(Member, ZSet::<a href="#type-iterator">iterator</a>(Scores, Members)) -&gt; Scores</tt>
<ul class="definitions"><li><tt>Member = Members</tt></li></ul></p>
</div><p>This function searches for a key in a zset. Returns {ok, Score} where Score is the score
       associated with Member, or error if the key is not present.</p>

<h3 class="function"><a name="intersection-2">intersection/2</a></h3>
<div class="spec">
<p><tt>intersection(Aggregate::fun((Scores, Scores) -&gt; Scores), ZSets::[<a href="#type-zset">zset</a>(Scores, Members), ...]) -&gt; <a href="#type-zset">zset</a>(Scores, Members)</tt><br></p>
</div><p>Returns the intersection of the non-empty list of ZSets generating the resulting scores using Aggregate in order.
       The last argument will be the accumulated result</p>

<h3 class="function"><a name="intersection-3">intersection/3</a></h3>
<div class="spec">
<p><tt>intersection(Aggregate::fun((Scores1, Scores2) -&gt; Scores3), ZSet1::<a href="#type-zset">zset</a>(Scores1, Members), ZSet2::<a href="#type-zset">zset</a>(Scores2, Members)) -&gt; <a href="#type-zset">zset</a>(Scores3, Members)</tt><br></p>
</div><p>Returns the intersection of ZSet1 and ZSet2 generating the resulting scores using Aggregate</p>

<h3 class="function"><a name="iterator-1">iterator/1</a></h3>
<div class="spec">
<p><tt>iterator(ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; <a href="#type-iterator">iterator</a>(Scores, Members)</tt><br></p>
</div><p>Equivalent to <a href="#iterator-2"><tt>iterator(ZSet, forward)</tt></a>.</p>


<h3 class="function"><a name="iterator-2">iterator/2</a></h3>
<div class="spec">
<p><tt>iterator(ZSet::<a href="#type-zset">zset</a>(Scores, Members), X2::<a href="#type-direction">direction()</a>) -&gt; <a href="#type-iterator">iterator</a>(Scores, Members)</tt><br></p>
</div><p>Returns an iterator that can be used for traversing the entries of Tree; see <a href="#next-1"><code>next/1</code></a>.</p>

<h3 class="function"><a name="list-3">list/3</a></h3>
<div class="spec">
<p><tt>list(Min::<a href="#type-limit">limit</a>(Scores), Max::<a href="#type-limit">limit</a>(Scores), ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; [{Scores, Members}]</tt><br></p>
</div><p>Equivalent to <a href="#list-4"><tt>list(Min, Max, ZSet, forward)</tt></a>.</p>


<h3 class="function"><a name="list-4">list/4</a></h3>
<div class="spec">
<p><tt>list(Min::<a href="#type-limit">limit</a>(Scores), Max::<a href="#type-limit">limit</a>(Scores), ZSet::<a href="#type-zset">zset</a>(Scores, Members), Direction::<a href="#type-direction">direction()</a>) -&gt; [{Scores, Members}]</tt><br></p>
</div><p>Returns the list of elements with scores between the specified limits</p>

<h3 class="function"><a name="map-2">map/2</a></h3>
<div class="spec">
<p><tt>map(Fun::fun((Scores, Members) -&gt; Scores2), ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; <a href="#type-zset">zset</a>(Scores2, Members)</tt><br></p>
</div><p>Executes Fun in each element and returns the zset with the scores returned by it</p>

<h3 class="function"><a name="new-0">new/0</a></h3>
<div class="spec">
<p><tt>new() -&gt; <a href="#type-zset">zset</a>(any(), any())</tt><br></p>
</div><p>Creates an empty <a href="#zset-2"><code>zset/2</code></a></p>

<h3 class="function"><a name="next-1">next/1</a></h3>
<div class="spec">
<p><tt>next(Iter1::<a href="#type-iterator">iterator</a>(Scores, Members)) -&gt; none | {Scores, Members, <a href="#type-iterator">iterator</a>(Scores, Members)}</tt><br></p>
</div><p>Returns {Score, Member, Iter2} where Score is the smallest score referred to by the iterator
  Iter1, and Iter2 is the new iterator to be used for traversing the remaining nodes, or the atom
  none if no nodes remain.</p>

<h3 class="function"><a name="range-3">range/3</a></h3>
<div class="spec">
<p><tt>range(Start::non_neg_integer(), Stop::non_neg_integer(), ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; [{Scores, Members}]</tt><br></p>
</div><p>Equivalent to <a href="#range-4"><tt>range(Start, Stop, ZSet, forward)</tt></a>.</p>


<h3 class="function"><a name="range-4">range/4</a></h3>
<div class="spec">
<p><tt>range(Start::non_neg_integer(), Stop::non_neg_integer(), ZSet::<a href="#type-zset">zset</a>(Scores, Members), Direction::<a href="#type-direction">direction()</a>) -&gt; [{Scores, Members}]</tt><br></p>
</div><p>Returns the list of elements between the Start'th one and the Stop'th one inclusive</p>

<h3 class="function"><a name="size-1">size/1</a></h3>
<div class="spec">
<p><tt>size(ZSet::<a href="#type-zset">zset</a>(any(), any())) -&gt; non_neg_integer()</tt><br></p>
</div><p>Returns the size of the zset</p>

<h3 class="function"><a name="to_list-1">to_list/1</a></h3>
<div class="spec">
<p><tt>to_list(ZSet::<a href="#type-zset">zset</a>(Scores, Members)) -&gt; [{Scores, Members}]</tt><br></p>
</div><p>Converts the sorted set into a list of {Score, Member} pairs</p>

<h3 class="function"><a name="union-2">union/2</a></h3>
<div class="spec">
<p><tt>union(Aggregate::fun((undefined | Scores, undefined | Scores) -&gt; Scores), ZSets::[<a href="#type-zset">zset</a>(Scores, Members), ...]) -&gt; <a href="#type-zset">zset</a>(Scores, Members)</tt><br></p>
</div><p>Returns the union of the non-empty list of ZSets generating the resulting scores using Aggregate in order.
       The last argument will be the accumulated result</p>

<h3 class="function"><a name="union-3">union/3</a></h3>
<div class="spec">
<p><tt>union(Aggregate::fun((Scores1, Scores2) -&gt; Scores3), ZSet1::<a href="#type-zset">zset</a>(Scores1, Members), ZSet2::<a href="#type-zset">zset</a>(Scores2, Members)) -&gt; <a href="#type-zset">zset</a>(Scores3, Members)</tt><br></p>
</div><p>Returns the union of ZSet1 and ZSet2 generating the resulting scores using Aggregate</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Nov 21 2011, 11:59:24.</i></p>
</body>
</html>
